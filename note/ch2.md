## ch2: 테스트에 대한 개요와 개발자가 해야 할 고민
### 1. 테스트란?
**테스트의 종류**
- 인수 테스트: 사람이 직접 해보면서 체크리스트 체크
- 자동 테스트: 미리 짜여진 코드로 결과값과 예상한 값 비교 -> 강의에서 다룰 내용

**테스트란 무엇일까요? 샘플**
- give, when, then과 같은 방식으로 테스트를 진행함 
- h2: RDB를 InMemory에 잠깐 띄워서 테스트할 수 있게 해줌

### 2. TDD
**TDD**
1. RED: 깨지는 테스트를 먼저 작성, 실패하는지까지 확인해야 함 
2. GREEN: 깨지는 테스트를 성공
3. BULE: 리팩토링 
- 3가지 절차를 걸쳐 개발하는 것
- 이 과정을 모든 개발 단계에서 무한히 반복하는 것이 TDD

**TDD의 장점**
1. 인터페이스를 먼저 만드는 것이 강제됨
- 깨지는 테스트를 먼저 작성해야 하기 때문
- 객체 지향의 핵심 원리 중 하나인 행동에 집중하게 함
- What/Who 사이클을 고민하게 도와준다: 어떤 행위를 누가 수행할지 결정하는 과정
2. 장기적인 관점에서 개발 비용 감소
- 신규 개발을 하게 되더라도 부담 없이 개발할 수 있음
- 테스트를 통해 이 개발로 인한 문제가 생겼는지를 한눈에 파악
- 장기적인 관점에서 개발 비용, 속도 감소 

**TDD의 단점**
1. 초기 개발 비용
- 요구사항이 명확하지 않거나 서비스의 흥망성쇠가 보이지 않는 경우 TDD를 적용하기 어려울 수 있음 
- 난이도가 있는 작업, 구성원의 숙련도가 뒷받침 되어야 함 

### 3. 개발자의 고민
1. 무의미한 테스트 (Recap)
- 명확한 코드에 테스트 코드가 유의미한지
- 모든 메서드를 테스트하는 것이 아니고, 중요한 로직을 구분해서 테스트를 적용하는 것이 좋음

2. 느리고 쉽게 깨지는 테스트

3. 테스트가 불가한 코드
- 예시) 사용자가 로그인을 하고, 마지막으로 로그인한 시점은 기록

=> 이런 고민들은 테스트가 보내는 신호일 수 있음, 이런 신호를 포착해서 좋은 설계를 유도하자 

## ch2: 테스트의 필요성과 테스트 3분류
### 1. 필요성
**테스트는 왜 필요한가? 레거시 코드**
- 레거시 코드: 테스트 루틴이 없는 코드 by 마이클 페더스 

**테스트는 왜 필요한가? Regression**
- Regression: 잘 돌아가던 코드가 이번 배포로 인해 동작하지 않는 상황
- Regression은 생각보다 큰 문제임, 자동 테스트를 도입하는 것이 생산성이 올라간다는 구글의 예시

**테스트는 왜 필요한가? 좋은 아키텍처를 유도**
- 좋은 아키텍처란? SOLID: 테스트와 긴밀한 상관관계를 가침, 서로 상호보완적인 관계
- 좋은 설계와 회귀 버그 방지를 놓치지 않아야 함 
  - S: 단일 책임 원칙 / 테스트는 명료하고 간단낳게 작성 -> 책임 분배
  - O: 개방 폐쇠 원칙 / 테스트와 프로덕션 컴포넌트를 나눠 작업하게 되고, 필요에 따라 탈부착 -> OCP를 지키게 됨
  - L: 리스코프 치환 원칙 / 이상적으로 테스트는 모든 케이스에 대해 커버, 치환 여부도 자동 판단
  - I: 인터페이스 분리 원칙 / 테스트는 그 자체로 인터페이스를 직접 사용해볼 수 있는 환경 
  - D: 의존성 역전 원칙 / 테스트에서 자주 사용하는 Fake, Dummy에 의해 지켜짐 
- 테스트 기능 설계
  - 품질 보증을 위한 도구 (회귀 버그 방지만을 목적)
  - 품질 보증 & 설계를 위한 도구라고 테스트를 생각했을 때 가치 상승

### 2. 테스트 3분류
**전통적인 테스트 3분류**
- API 테스트, 통합 테스트, 단위 테스트

**구글의 테스트 3분류**
- 소형 테스트: 단일 서버, 단일 프로세스, 단일 스레드, 디스크 I/O 사용해선 안됨, Blocking call 허용 안됨
- 중형 테스트: 단일 서버, 멀티 프로세스, 멀티 스레드 -> h2 같은 테스트 DB를 사용할 수 있다
- 대형 테스트: 멀티 서버, E2E 테스트
- 스프링 개발자들은 중형 테스트를 많이 만드는 실수를 함
- 소형 테스트에 집중하는 것이 중요 

## ch2: 테스트에 필요한 개념
### 1. 개념
- SUT: 테스트하려는 대상 
- BDD: 행동에 집중해야 한다는 것을 강조해줌, given-when-then
- 상호작용 테스트: 메서드가 실제 호출됐는지 검증하는 기법 -> 캡슐화에 위배
- 상태 검증 vs 행위 검증
    - 상태 검증: 어떤 값을 시스템에 넣었을 때, 나오는 결과값을 기댓값과 비교
    - 행위 검증: 어떤 값을 시스템에 넣었을 때, 협력 객체의 어떤 메서드를 실행하는가 / 상호작용 테스트
- 테스트 픽스처: 테스트에 필요한 자원을 생성하는 것 
    - @BeforeEach
    - sut가 될 수도, sut에 들어가야 하는 의존성 의부가 될 수도 있음
    - 가급적으로 사용하지 않는 편
- 비욘세 규칙
    - 유지하고 싶은 상태나 정책이 있다면 직접 테스트를 만들어야 함
    - 테스트는 프로그램이 지켜야 할 제약과 같은 건
- Testability: 테스트 가능성, 소프트웨어가 테스트 가능한 구조인가?
- test double: 테스트 대역
    - 가짜 객체 

### 2. 대역
- Dummy
  - 아무런 동작도 하지 않음
  - 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
- Fake: 
  - Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체
  - 자체적인 로직이 있다는 것이 특징 
- Stub
  - 미리 준비된 값을 출력하는 객체
  - 외부 연동하는 컴포넌트에 많이 사용함
  - mockito 프레임워크를 이용해 구현되기도 함 
- Mock
  - 메소드 호출을 확인하기 위한 객체, 자가 검증 능력을 갖춤
  - 사실상 테스트 더블과 동일한 의미로 사용됨
- Spy
  - 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체

## ch2: 의존성과 Testability
### 1. 의존성
- 의존성이란: A는 B를 사용하기만 해도 의존한다고 볼 수 있음
- 의존성 주입(DI): 의존성을 약하게 만드는 대표적인 테크닉 중 하나, 그러나 의존성을 완전히 제거할 수는 없음
- 의존성 역전(DIP): 의존성 주입과 완전히 다른 개념 
  - 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
  - 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다. 
  - 인터페이스와 구현을 분리
  - 화살표의 방향을 바꾸는 테크닉 

### 2. 의존성과 테스트
- 테스트를 잘 하려면 의존성 주입과 의존성 역전을 잘 다룰 수 있어야 함.
- ex) 마지막 로그인 시간
  - 내부 로직을 보면 login 메서드는 Clock을 사용하고 있음 -> Clock에 의존적
  - 외부에서 login을 사용할 때는 Clock을 사용하는지 모름 -> 의존성이 숨겨져 있으면 좋지 않은 신호
  - 테스트가 불가능하거나, mock 프레임워크 없이 불가능
  - 의존성 주입으로 해결: Clock을 외부에서 주입하도록 설정해서 해결 but 이렇게 되면 login 메서드를 사용하는 UserService에 의존성이 숨겨짐, 문제의 반복
  - 의존성 주입 + 의존성 역전으로 해결: interface인 ClockHolder를 사용해서 해결 
- SOLID -> DIP: 의존성 역전 원칙, 대부분의 소프트웨어 문제는 의존성 역전으로 해결 가능하다

### 3. Testability
- 테스트 가능성: 얼마나 쉽게 input을 변경하고, ouput을 검증할 수 있는가?

**input과 관련된 낮은 testability**
- 감춰진 의존성: 
  - 호출자는 모르는 입력이 존재함, 캡슐화가 깨짐 -> testability 낮음
  - 어거지  테스트로 해결하지 않고, 의존성 역전으로 해결하여서 설계를 고쳐야 함
- 하드 코딩: 
  - 파일이 존재하지 않을 때 테스트할 수 없음
  - input 변경이 어려움 
- 외부 시스템: 
  - 하드 코딩된 외부 시스템과 연동이 되어있는 경우
  - WebClient, RestTemplate와 같은 외부 시스템을 사용하는 경우
  
**output과 관련된 낮은 testability**
- 감춰진 결과: 
  - 외부에서 결과를 볼 수 없는 경우 
  - ex. 콘솔 출력 

## ch2: 실기 전 사전 탐색 
### 1. 빌더
- Builder pattern: 생서앚가 지나치게 많아지는 문제를 해결할 수 있는 유연한 해결책 
- 롬복의 @Builder 어노테이션 -> builder() 메서드 
- 빌더의 장점: "테스트 객체의 구조적인 변화로부터 테스트를 다시 한 번 보호한다"
  - 테스트에 new를 이용해서 객체를 인스턴스로 만든 상황: 생성자에 파라미터를 하나라도 더 늘리면 컴파일 에러
  - 빌더 패턴이 이런 상황을 예방해줄 수 있음
  - 생성자를 하나로 관리할 수 있음, 긴 파라미터를 정리할 수 있음
- 빌더의 단점: 종종 필요한 파라미터를 누락하는데, 컴파일러가 이를 캐치하지 못할 수 있음

### 2. 엔티티
- 도메인 엔티티, 영속성 객체, DB 엔티티 개념을 구분할 수 있어야 함
- 엔티티는 JPA와 상관이 없음
- DocumentDB에서는 Jpa를 따르지 않음 
1. 도메인 엔티티
- 소프트웨어에서 어떤 도메인이나 문제를 해결하기 위해 만들어진 모델
- 도메인 객체와 혼용되어 쓰이는 용어
- 개발 세계에서 말하는 엔티티
- "비즈니스 영역을 해결하는 모델"
2. DB 엔티티
- 데이터베이스 분야에서 유/무형의 객체를 표현하기 위해 사용 
- 도메인 엔티티와 해결책이 다름
- "RDB에 저장되는 객체"
3. 영속성 객체  
- DB 엔티티의 값을 도메인 엔티티로 옮겨야 함 -> 영속성 객체, JPA
- 이 역할을 확실히 하기 위해 JPA를 통해 작성 
- "ORM(Object Relational (database) Mapping"

### 3. 기타 조언
- private/final 메소드
  - private 메소드는 테스트하지 않아도 됨
  - private 메소드를 테스트하고 싶다면, 사실 private가 아니어도 되거나 다른 클래스로 분리/책임을 위임하여 public으로 만들라는 신호
  - final 메소드를 stub하는 상황을 피해야 함 (ex. User가 final인 UUID를 가지는 경우)
- DRY < DAMP
  - 테스트와 코드 공유는 DRY가 아니라 DAMP로 
  - 테스트할 때 만큼은 중복되더라도 가독성이 좋은 편이 낫다는 의미
- 논리 로직을 피하라(+, FOR, IF...)
  - 간단한 논리 로직 때문에 테스트 코드에 예측하지 못하는 버그가 발생할 수 있음 
